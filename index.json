[{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.chenjr.top/projects/a_project/","tags":null,"title":"calldiff"},{"categories":null,"contents":"   Q1. 检查句子中的数字是否递增   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/check-if-numbers-are-ascending-in-a-sentence/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  模拟。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Algorithm: simulation // Time Complexity: O(n), n = len(s) // Space Complexity: O(n) func areNumbersAscending(s string) bool { last := -1 for _, split := range strings.Split(s, \u0026#34; \u0026#34;) { if unicode.IsDigit(rune(split[0])) { if curr, _ := strconv.Atoi(split); last \u0026lt; curr { last = curr } else { return false } } } return true }      Q2. 简易银行系统   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/simple-bank-system/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  模拟。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // Algorithm: simulation // Time Complexity: O(1) // Space Complexity: O(1) type Bank struct{ balance []int64 } func Constructor(balance []int64) Bank { return Bank{balance: balance} } func (this *Bank) Transfer(account1 int, account2 int, money int64) bool { if account1 \u0026lt;= 0 || account1 \u0026gt; len(this.balance) || account2 \u0026lt;= 0 || account2 \u0026gt; len(this.balance) || this.balance[account1-1] \u0026lt; money { return false } this.balance[account1-1] -= money this.balance[account2-1] += money return true } func (this *Bank) Deposit(account int, money int64) bool { if account \u0026lt;= 0 || account \u0026gt; len(this.balance) { return false } this.balance[account-1] += money return true } func (this *Bank) Withdraw(account int, money int64) bool { if account \u0026lt;= 0 || account \u0026gt; len(this.balance) || this.balance[account-1] \u0026lt; money { return false } this.balance[account-1] -= money return true }      Q3. 统计按位或能得到最大值的子集数目   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  由于数组的值都大于 $0$，所以显然异或的最大值是所有值的异或和；观察数据范围，位运算枚举即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Algorithm: bitwise enumerate // Time Complexity: O(n * 2^n), n = len(nums) // Space Complexity: O(1) func countMaxOrSubsets(nums []int) int { maximum := 0 for _, num := range nums { maximum |= num } n := len(nums) ans := 0 for mask := 1\u0026lt;\u0026lt;n - 1; mask \u0026gt;= 0; mask -= 1 { sum := 0 for bit := 0; bit \u0026lt; n; bit += 1 { if mask\u0026amp;(1\u0026lt;\u0026lt;bit) \u0026gt; 0 { sum |= nums[bit] } } if sum == maximum { ans += 1 } } return ans }      Q4. 到达目的地的第二短时间   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  存储两个最短时间的 Dijkstra 算法。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  // Algorithm: dijkstra // Time Complexity: O(E \\log V) // Space Complexity: O(E) type Item struct { position int time int // The index is needed by update and is maintained by the heap.Interface methods. \tindex int // The index of the item in the heap. } type priority_queue []*Item func (h priority_queue) Len() int { return len(h) } func (h priority_queue) Less(i, j int) bool { return h[i].time \u0026lt; h[j].time } // \u0026gt; 为最大堆 func (h priority_queue) Swap(i, j int) { h[i], h[j] = h[j], h[i]; h[i].index = i; h[j].index = j } func (h *priority_queue) Push(v interface{}) { *h = append(*h, v.(*Item)) } func (h *priority_queue) Pop() interface{} { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v } func (h *priority_queue) push(item *Item) { item.index = len(*h); heap.Push(h, item) } func (h *priority_queue) pop() *Item { return heap.Pop(h).(*Item) } func secondMinimum(n int, edges [][]int, time int, change int) int { adj := make([][]int, n+1) for _, edge := range edges { u, v := edge[0], edge[1] adj[u] = append(adj[u], v) adj[v] = append(adj[v], u) } distance := make([][2]int, n+1) for i := 1; i \u0026lt;= n; i += 1 { distance[i][0], distance[i][1] = -1, -1 } h := \u0026amp;priority_queue{\u0026amp;Item{position: 1, time: 0, index: 0}} for h.Len() \u0026gt; 0 { curr := h.pop() if curr.time/change%2 == 1 { curr.time = (curr.time/change + 1) * change } for _, next := range adj[curr.position] { if distance[next][0] == -1 { distance[next][0] = curr.time + time } else if distance[next][0] != curr.time+time \u0026amp;\u0026amp; distance[next][1] == -1 { distance[next][1] = curr.time + time } else { continue } if distance[n][1] != -1 { return curr.time + time } h.push(\u0026amp;Item{position: next, time: curr.time + time}) } } return 0 }   ","date":"Oct 17","permalink":"https://blog.chenjr.top/post/leetcode-weekly-263/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 263 场周赛"},{"categories":null,"contents":"   Q1. 使每位学生都有座位的最少移动次数   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/minimum-number-of-moves-to-seat-everyone/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  直觉上，我们应该对两个数组进行排序，然后从左到右每个学生依次坐在从左到右的各个位置上。\n下面我们采用反证法进行证明，也即需要证明任意调换位置，最终的移动次数只会不变或增多。\n假设 $a \\leq b$, $c \\leq d$, 则需要证明 $|a-c| + |b-d| \\leq |a-d| + |b-c|$。\n方便起见，同时保证结果不受影响，我们让四个数同减去 $a$，证明如下\n$$ \\begin{align} |c|+|b-d| \u0026amp;\\leq |d|+|b-c| \\\nc^2+2|c||b-d| +(b-d)^2 \u0026amp;\\leq d^2+2|d||b-c| +(b-c)^2 \\\n|c||b-d|-bd \u0026amp;\\leq |d||b-c|-bc \\\n|c||b-d| - |d||b-c| \u0026amp;\\leq b(d-c) \\\n|bc-cd|-|bd-cd| \u0026amp;\\leq b|d-c| \\\n|bc-cd|-|bd-cd| \u0026amp;\\leq |bd-bc| \\end{align} $$\n此外，我们知道 $-|x| \\leq x \\leq |x|, -|y| \\leq y \\leq |y|$，相加可得 $-(|x|+|y|) \\leq x + y \\leq |x|+|y|$，可得 $x+y \\leq |x+y| \\leq ||x|+|y||$。故 $|x+y|\\leq|x|+|y|$；令$x=x-y$，可得$|x|\\leq|x-y|+|y|$，也即 $|x|-|y|\\leq|x-y|$。\n那么可以得到 $|bc-cd|-|bd-cd|\\leq|bc-bd|$，得证。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // Algorithm: math // Time Complexity: O(n \\log n + m \\log m), n = len(seats), m = len(students) // Space Complexity: O(1) func minMovesToSeat(seats []int, students []int) int { sort.Ints(seats) sort.Ints(students) abs := func(x int) int { if x \u0026lt; 0 { return -x } return x } ans := 0 for i := range seats { ans += abs(seats[i] - students[i]) } return ans }      Q2. 如果相邻两个颜色均相同则删除当前颜色   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  比较符合要求的颜色数量即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Algorithm: traverse // Time Complexity: O(n), n = len(colors) // Space Complexity: O(1) func winnerOfGame(colors string) bool { count := func(color byte) int { cnt := 0 for i := 1; i+1 \u0026lt; len(colors); i += 1 { if colors[i-1] == color \u0026amp;\u0026amp; colors[i] == color \u0026amp;\u0026amp; colors[i+1] == color { cnt += 1 } } return cnt } return count(\u0026#39;A\u0026#39;) \u0026gt; count(\u0026#39;B\u0026#39;) }      Q3. 网络空闲的时刻   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  由于图中的边权全为 $1$，故不需要进行松弛操作。我们可以通过广度优先搜索在 $\\mathcal{O}(n)$ 时间内得到主服务器到各个服务器之间的最短距离。\n另外还需要考虑重发的情况，假设服务器 $i$ 到主服务器的最短距离为 $distance[i]$，那么需要 $2distance[i]$ 的时间得到回复。所以在 $2distance[i] -1$的时间内，服务器 $i$ 会进行重试，简单计算可知，其最后一条发送的信息会在 $\\lfloor \\frac{2distance[i]-1}{patient[i]} \\rfloor * patient[i]$ 后收到，则总时间为$2distance[i] + \\lfloor \\frac{2*distance[i]-1}{patient[i]} \\rfloor * patient[i]$。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  // Algorithm: bfs + math // Time Complexity: O(n), n = len(patience) // Space Complexity: O(n) func networkBecomesIdle(edges [][]int, patience []int) int { n := len(patience) // construct graph \tadj := make([][]int, n) for _, edge := range edges { u, v := edge[0], edge[1] adj[u] = append(adj[u], v) adj[v] = append(adj[v], u) } // bfs \tdistance := make([]int, n) q := make([]int, 0, n) q = append(q, 0) for len(q) \u0026gt; 0 { cur := q[0] q = q[1:] for _, next := range adj[cur] { if distance[next] == 0 { distance[next] = distance[cur] + 1 q = append(q, next) } } } // get maximum cost \tans := 0 for i := 1; i \u0026lt; n; i += 1 { if cost := 2*distance[i] + (2*distance[i]-1)/patience[i]*patience[i]; cost \u0026gt; ans { ans = cost } } return ans + 1 }      Q4. 两个有序数组的第 K 小乘积   来源：力扣（LeetCode）\n链接： https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  二分套二分，注意细节。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  // Algorithm: binary search // Time Complexity: O(n \\log C), n = len(nums2), C = 2e10 // Space Complexity: O(1) func kthSmallestProduct(nums1 []int, nums2 []int, k int64) int64 { sort.Ints(nums1) sort.Ints(nums2) sort.SearchInts(nums1, 0) ok := func(mid int) bool { cnt := int64(0) for _, num := range nums1 { if num == 0 { if mid \u0026gt;= 0 { cnt += int64(len(nums2)) } } else if num \u0026gt; 0 { cnt += int64(sort.Search(len(nums2), func(i int) bool { return nums2[i]*num \u0026gt; mid })) } else { cnt += int64(len(nums2) - sort.Search(len(nums2), func(i int) bool { return nums2[i]*num \u0026lt;= mid })) } } return cnt \u0026gt;= k } low, high := -10_000_000_000, 10_000_000_000 for low+1 \u0026lt; high { mid := low + (high-low)/2 if ok(mid) { high = mid } else { low = mid + 1 } } if ok(low) { return int64(low) } return int64(high) }   ","date":"Oct 17","permalink":"https://blog.chenjr.top/post/leetcode-biweekly-63/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 63 场双周赛"},{"categories":["周赛"],"contents":"   Q1. 至少在两个数组中出现的值   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/two-out-of-three/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  集合。\n   代码  1 2 3 4 5 6 7  # Algorithm: set # Time Complexity: O(n), n = sum(len(nums{1..3})) # Space Complexity: O(n) class Solution: def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -\u0026gt; List[int]: s1, s2, s3 = set(nums1), set(nums2), set(nums3) return list((s1 \u0026amp; s2) | (s2 \u0026amp; s3) | (s1 \u0026amp; s3))      Q2. 获取单值网格的最小操作数   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  中位数。原型是 462. 最少移动次数使数组元素相等 II。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14  # Algorithm: midian # Time Complexity: O(row * col), row = len(grid), col = len(grid[0]) # Space Complexity: O(row * col) class Solution: def minOperations(self, grid: List[List[int]], x: int) -\u0026gt; int: nums = list() for row in grid: for num in row: if abs(grid[0][0] - num) % x != 0: return -1 nums.append(num) nums.sort() return sum([abs(num - nums[len(nums) // 2]) // x for num in nums])      Q3. 股票价格波动   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/stock-price-fluctuation/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  模拟。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Algorithm: simulation // Time Complexity: O(log n), n = prices.size() // Space Complexity: O(n) class StockPrice { private: // timestamp -\u0026gt; price  map\u0026lt;int, int\u0026gt; time2price; // current prices  multiset\u0026lt;int\u0026gt; prices; public: StockPrice() {} void update(int timestamp, int price) { if (time2price.find(timestamp) != time2price.end()) { int oldPrice = time2price[timestamp]; prices.erase(prices.find(oldPrice)); } time2price[timestamp] = price; prices.emplace(price); } int current() { return time2price.rbegin()-\u0026gt;second; } int maximum() { return *prices.rbegin(); } int minimum() { return *prices.begin(); } };      Q4. 将数组分成两个数组并最小化数组和的差   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  Meet in the middle.\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  // Algorithm: meet in the middle // Time Complexity: O(n * 2^n * log C(n, n/2)), n = len(nums) / 2 // Space Complexity: O(n * 2^n) func minimumDifference(nums []int) int { construct := func(slice []int, all [][]int) { // unique \tseen := make([]map[int]struct{}, len(slice)+1) for i := range seen { seen[i] = make(map[int]struct{}) } // enumerate \tfor mask := 0; mask \u0026lt; 1\u0026lt;\u0026lt;len(slice); mask += 1 { ones, total := 0, 0 for bit := 0; bit \u0026lt; len(slice); bit += 1 { if mask\u0026amp;(1\u0026lt;\u0026lt;bit) \u0026gt; 0 { total += slice[bit] ones += 1 } } if _, ok := seen[ones][total]; !ok { all[ones] = append(all[ones], total) seen[ones][total] = struct{}{} } } for i := range all { sort.Ints(all[i]) } } // reduce by half \tn := len(nums) / 2 lhs, rhs := make([][]int, n+1), make([][]int, n+1) construct(nums[:n], lhs) construct(nums[n:], rhs) // sum(nums) \tsum := 0 for _, num := range nums { sum += num } // meet in the middle \tans := math.MaxInt32 for i := 0; i \u0026lt;= n; i += 1 { for _, leftSum := range lhs[i] { j := sort.SearchInts(rhs[n-i], sum/2-leftSum) for k := -1; k \u0026lt;= 1; k += 1 { if j+k \u0026gt;= 0 \u0026amp;\u0026amp; j+k \u0026lt; len(rhs[n-i]) { rightSum := rhs[n-i][j+k] minus := sum - 2*leftSum - 2*rightSum if minus \u0026lt; 0 { minus = -minus } if minus \u0026lt; ans { ans = minus } } } } } return ans }   ","date":"Oct 10","permalink":"https://blog.chenjr.top/post/leetcode-weekly-262/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 262 场周赛"},{"categories":["周赛"],"contents":"   Q1. 统计平方和三元组的数目   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/count-square-sum-triples/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  第一题无脑暴力 $O(n^3)$ 即可。\n赛后补一份容易想到的 $O(n^2)$ 的双指针代码。评论区给出了复杂度更低的算法，但需要前置的数学知识，并不太容易在面试中想出来，在这里也就不再赘述了。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Algorithm: two pointers # Time Complexity: O(n^2) # Space Complexity: O(1) class Solution: def countTriples(self, n: int) -\u0026gt; int: ans = 0 for c in range(1, n + 1): target = c * c a, b = 1, c - 1 while a \u0026lt;= b: result = a * a + b * b if result == target: ans += 1 if a == b else 2 a += 1 b -= 1 elif result \u0026lt; target: a += 1 else: b -= 1 return ans      Q2. 迷宫中离入口最近的出口   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  一道比较无脑的搜索题。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Alogrithm: bfs // Time Complexity: O(n * m), n = maze.size(), m = maze[0].size() // Space Complexity: O(n * m) class Solution { public: int nearestExit(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;maze, vector\u0026lt;int\u0026gt; \u0026amp;entrance) { int row = maze.size(), col = maze[0].size(); // in order to use `set` to find coordinate (x, y) that we have processed before,  // we transform it into an unique value  auto position = [\u0026amp;col](int x, int y) { return col * x + y; }; unordered_set\u0026lt;int\u0026gt; seen; seen.emplace(position(entrance[0], entrance[1])); queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; q.emplace(entrance[0], entrance[1]); constexpr array\u0026lt;pair\u0026lt;int, int\u0026gt;, 4\u0026gt; dir{{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}}; int step = 0; while (not q.empty()) { for (auto _ = q.size(); _ \u0026gt; 0; --_) { auto [x, y] = q.front(); q.pop(); for (auto \u0026amp;\u0026amp;[dx, dy] : dir) { int nx = x + dx, ny = y + dy; if (nx \u0026gt;= 0 and nx \u0026lt; row and ny \u0026gt;= 0 and ny \u0026lt; col and maze[nx][ny] == \u0026#39;.\u0026#39; and seen.find(position(nx, ny)) == seen.end()) { seen.emplace(position(nx, ny)); if (nx == 0 or nx == row - 1 or ny == 0 or ny == col - 1) { return step + 1; } q.emplace(nx, ny); } } } step += 1; } return -1; } };      Q3. 求和游戏   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sum-game/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  分类讨论的博弈论问题。\n理清楚之后翻译成代码即可。\n    代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  # Algorithm: category discussion # Time Complexity: O(n), n = len(num) # Space Complexity: O(1) class Solution: def sumGame(self, num: str) -\u0026gt; bool: # number of \u0026#39;?\u0026#39; leftQuestion = rightQuestion = 0 # sum leftSum = rightSum = 0 for idx, char in num: if char == \u0026#39;?\u0026#39;: if idx \u0026lt; len(num) // 2: leftQuestion += 1 else: rightQuestion += 1 else: if idx \u0026lt; len(num) // 2: leftSum += int(char) else: rightSum += int(char) # discussion if (leftQuestion + rightQuestion) % 2 == 1: return True if leftQuestion == rightQuestion and leftSum == rightSum: return False if (leftQuestion \u0026gt; rightQuestion and leftSum \u0026lt; rightSum) or ( leftQuestion \u0026lt; rightQuestion and leftSum \u0026gt; rightSum): if abs(leftQuestion - rightQuestion) // 2 * 9 == abs(leftSum - rightSum): return False return True      Q4. 规定时间内到达终点的最小花费   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  二维的最短路径问题，观察到数据范围 $1 \\le maxTime \\le 1000$ 以及 $2 \\le n \\le 1000$，可以想到使用动态规划进行求解。\n我们定义 $dp[t][x]$ 为在时刻 $t$ 到达城市 $x$ 的最小花费。那么对于城市 $x$ 的邻居 $y$，假设二者之间的耗时为 $time$，我们有以下状态转移方程：\n$$ dp[t + time][y] = \\min (dp[t + time][y], dp[t][x] + passingFees[y]) $$\n注意到 $n - 1 \\le edges.length \\le 1000$，故总体的计算量只会到 $10^6$ 量级，可以通过本题。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # Algorithm: dynamic programming # Time Complexity: O(maxTime * m), m = edges.length # Space Complexity: O(maxTime * n) class Solution: def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -\u0026gt; int: # process edges adj = defaultdict(lambda: defaultdict(lambda: inf)) for x, y, time in edges: adj[x][y] = adj[y][x] = min(adj[x][y], time) n = len(passingFees) # dp[t][x]: at time t, arrive at city x, minimum cost dp = [[inf] * n for _ in range(maxTime + 1)] dp[0][0] = passingFees[0] for t in range(maxTime + 1): for x in range(n): if dp[t][x] != inf: for y, time in adj[x].items(): if t + time \u0026lt;= maxTime: dp[t + time][y] = min(dp[t + time][y], dp[t][x] + passingFees[y]) ans = min([dp[t][n - 1] for t in range(maxTime + 1)]) return ans if ans != inf else -1   ","date":"Jul 16","permalink":"https://blog.chenjr.top/post/leetcode-biweekly-56/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 56 场双周赛"},{"categories":["周赛"],"contents":"起晚了没赶上:(\n   Q1. 基于排列构建数组   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/build-array-from-permutation/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  阅读理解。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Algorithm: simulation // Time Complexity: O(n), n = nums.size() // Space Complexity: O(n) class Solution { public: vector\u0026lt;int\u0026gt; buildArray(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; ans(n); for (int i = 0; i \u0026lt; n; ++i) { ans[i] = nums[nums[i]]; } return ans; } };      Q2. 消灭怪物的最大数量(\u0026lt;a href=\u0026#34;https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters/\u0026#34;\u0026gt;https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters/\u0026lt;/a\u0026gt;)   来源：力扣（LeetCode）\n链接：[]\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  在 $t_0(t_0 \\in \\mathbb{Z})$ 时刻，我们可以消灭到达时间为 $(t_0, \\infty)$ 的怪物。\n只需要将怪物的到达时间向上取整并排序，贪心消灭即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // Algorithm: sort + greed // Time Complexity: O(n), n = dist.size() // Space Complexity: O(n) class Solution { public: int eliminateMaximum(vector\u0026lt;int\u0026gt; \u0026amp;dist, vector\u0026lt;int\u0026gt; \u0026amp;speed) { int n = dist.size(); vector\u0026lt;double\u0026gt; time(n); for (int i = 0; i \u0026lt; n; ++i) { time[i] = ceil(1. * dist[i] / speed[i]); } sort(time.begin(), time.end()); for (int i = 0; i \u0026lt; n; ++i) { if (time[i] \u0026lt;= i) { return i; } } return n; } };      Q3. 统计好数字的数目(\u0026lt;a href=\u0026#34;https://leetcode-cn.com/problems/count-good-numbers/\u0026#34;\u0026gt;https://leetcode-cn.com/problems/count-good-numbers/\u0026lt;/a\u0026gt;)   来源：力扣（LeetCode）\n链接：[]\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  奇数位置有 2, 3, 5, 7 四种选择，偶数位置有 0, 2, 4, 6, 8 五种选择。\n根据排列组合原理可知这是乘法关系。\n题目中说明可以包括前导零，所以好数字的数目即\n$$ ans = 4^{\\lfloor \\dfrac{n}{2} \\rfloor} * 5 ^{\\lceil \\dfrac{n}{2} \\rceil} $$\n只需要简单地进行快速幂处理并取模即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Algorithm: math + quick pow // Time Complexity: O(\\log n) // Space Complexity: O(1) class Solution { private: static constexpr int mod = 1\u0026#39;000\u0026#39;000\u0026#39;007; public: int countGoodNumbers(long long n) { // quick pow  auto qpow = [\u0026amp;](int64_t x, int64_t y) { int64_t ans = 1; while (y) { if (y \u0026amp; 1) { ans = (ans * x) % mod; } x = (x * x) % mod; y \u0026gt;\u0026gt;= 1; } return ans; }; // odd indices count and even indices count  int64_t odd = floor(n / 2.0), even = ceil(n / 2.0); int64_t ans = (qpow(4, odd) * qpow(5, even)) % mod; return ans; } };      Q4. 最长公共子路径(\u0026lt;a href=\u0026#34;https://leetcode-cn.com/problems/longest-common-subpath/\u0026#34;\u0026gt;https://leetcode-cn.com/problems/longest-common-subpath/\u0026lt;/a\u0026gt;)   来源：力扣（LeetCode）\n链接：[]\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  滚动哈希，二分查找。但是可能会有碰撞，导致答案错误。\n更好的解法是后缀数组(TODO)。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  // Algorithm: rolling hash + binary search // Time Complexity: O(n \\log n) // Space Complexity: O(n) class Solution { public: int longestCommonSubpath(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;paths) { uint64_t mod = numeric_limits\u0026lt;uint64_t\u0026gt;::max() / n / 10; // check if there is common subpath which length is `len`  auto check = [\u0026amp;](int len) { unordered_set\u0026lt;uint64_t\u0026gt; seen; uint64_t base = 1; for (int _ = 1; _ \u0026lt; len; ++_) { base = (base * n) % mod; } for (int i = 0; i \u0026lt; static_cast\u0026lt;int\u0026gt;(paths.size()); ++i) { unordered_set\u0026lt;uint64_t\u0026gt; now; uint64_t curr = 0; for (int j = 0; j \u0026lt; static_cast\u0026lt;int\u0026gt;(paths[i].size()); ++j) { curr = (curr * n + paths[i][j]) % mod; if (j \u0026gt;= len - 1) { if (i == 0 or seen.find(curr) != seen.end()) { now.emplace(curr); } curr = (curr - (paths[i][j - len + 1] * base) % mod + mod) % mod; } } if (now.empty()) { return false; } seen = move(now); } return true; }; // binary search  int low = 0, high = numeric_limits\u0026lt;int\u0026gt;::max(); for (auto \u0026amp;\u0026amp;path : paths) { high = min(high, static_cast\u0026lt;int\u0026gt;(path.size())); } while (low \u0026lt; high) { int mid = (low + high + 1) / 2; if (check(mid)) { low = mid; } else { high = mid - 1; } } return low; } };   ","date":"Jul 04","permalink":"https://blog.chenjr.top/post/leetcode-weekly-248/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 248 场周赛"},{"categories":["周赛"],"contents":"   Q1. 两个数对之间的最大乘积差   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  注意到数据范围 1 \u0026lt;= nums[i] \u0026lt;= 10^4，可以想到使用排序解决本问题。\n   代码  1 2 3 4 5 6 7  # Algorithm: sort + greed # Time Complexity: O(n), n = len(nums) # Space Complexity: O(1) class Solution: def maxProductDifference(self, nums: List[int]) -\u0026gt; int: nums.sort() return nums[-1] * nums[-2] - nums[0] * nums[1]      Q2. 循环轮转矩阵   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/cyclically-rotating-a-grid/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  模拟即可，注意细节。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Algorithm: simulation # Time Complexity: O(n * m), n = len(grid), m = len(grid[0]) # Space Complexity: O(n + m) class Solution: def rotateGrid(self, grid: List[List[int]], k: int) -\u0026gt; List[List[int]]: n, m = len(grid), len(grid[0]) for i in range(ceil(min(n, m) / 2)): nums = list() x = y = i # x, y = i, i while y \u0026lt; m - i - 1: nums.append((x, y, grid[x][y])) y += 1 # x, y = i, m - i - 1 while x \u0026lt; n - i - 1: nums.append((x, y, grid[x][y])) x += 1 # x, y = n - i - 1, m - i - 1 while y \u0026gt; i: nums.append((x, y, grid[x][y])) y -= 1 # x, y = n - i - 1, i while x \u0026gt; i: nums.append((x, y, grid[x][y])) x -= 1 # x, y = i, i for idx, (x, y, _) in enumerate(nums): _, _, val = nums[(idx + k) % len(nums)] grid[x][y] = val return grid      Q3. 最美子字符串的数目   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/number-of-wonderful-substrings/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  子字符串问题往前缀和方向思考；子序列问题往动态规划方向思考。\n显然本题中只需要记录前缀字符串的奇偶情况即可，由于数据量很小，考虑使用状态压缩进行优化。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Algorithm: prefix cnt + state compression // Time Complexity: O(n), n = len(word) // Space Complexity: O(2^m), m = \\Sigma class Solution { public: long long wonderfulSubstrings(string word) { long long ans = 0; int state = 0; array\u0026lt;int, 1 \u0026lt;\u0026lt; 10\u0026gt; cnt{}; cnt[0] += 1; for (auto \u0026amp;\u0026amp;ch : word) { state ^= 1 \u0026lt;\u0026lt; (ch - \u0026#39;a\u0026#39;); // no letter appears an odd number of times  ans += cnt[state]; // at most one letter appears an odd number of times  for (int i = 0; i \u0026lt; 10; ++i) { ans += cnt[state ^ (1 \u0026lt;\u0026lt; i)]; } cnt[state] += 1; } return ans; } };      Q4. 统计为蚁群构筑房间的不同顺序   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路   如上图所示，假设我们已经得到了所有子节点的 $dp[child]$ 以及 $sz[child]$，那么我们可以得出以下计算公式：\n$$ dp[root] = \\left ( \\prod_{i = 0}^{childCnt} dp[child_i] \\right ) \\times \\frac{(sz[root] - 1)!}{\\left( \\prod_{i = 0}^{childCnt} sz[child_i]! \\right)} $$\n其中乘号左边的部分是各子节点的方案数，是乘法关系。乘号右边是将各子节点归并排列的组合方式，其中分子即子节点的全排列方式，由于每个子树有且仅有一种排列方式，所以还需要除去分母部分。\n由于除法不满足模运算的分配律，所以除去分母部分需要用到乘法逆元。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  // Algorithm: tree type dynamic programming // Time Complexity: O(n), n = prevRoom.size() // Space Complexity: O(n) class Solution { private: static constexpr int mod = 1\u0026#39;000\u0026#39;000\u0026#39;007; public: int waysToBuildRooms(vector\u0026lt;int\u0026gt; \u0026amp;prevRoom) { int n = prevRoom.size(); // factorial  vector\u0026lt;int64_t\u0026gt; factorial(n, 1); for (int i = 2; i \u0026lt; n; ++i) { factorial[i] = (factorial[i - 1] * i) % mod; } // (x ^ y) % mod  auto qpow = [\u0026amp;](int64_t x, int y) { int64_t ans = 1; while (y) { if (y \u0026amp; 1) { ans = (ans * x) % mod; } x = (x * x) % mod; y \u0026gt;\u0026gt;= 1; } return ans; }; // construct map  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; children(n); for (int i = 1; i \u0026lt; n; i++) { children[prevRoom[i]].emplace_back(i); } // dfs  vector\u0026lt;int64_t\u0026gt; dp(n, 1), sz(n, 1); function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int root) { for (auto \u0026amp;\u0026amp;child : children[root]) { dfs(child); sz[root] += sz[child]; dp[root] = (dp[root] * dp[child]) % mod; dp[root] = (dp[root] * qpow(factorial[sz[child]], mod - 2)) % mod; } dp[root] = (dp[root] * factorial[sz[root] - 1]) % mod; }; dfs(0); return dp[0]; } };   ","date":"Jul 01","permalink":"https://blog.chenjr.top/post/leetcode-weekly-247/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 247 场周赛"},{"categories":["周赛"],"contents":"   Q1. 删除一个元素使数组严格递增   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  观察并分析，可以发现仅存在两种合法情况，逐一考虑即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // Algorithm: two pointer // Time Complexity: O(n), n = nums.size() // Space Complexity: O(1) class Solution { public: bool canBeIncreasing(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(); // if we remove nums[x], whether array is increasing  auto check = [\u0026amp;](int x) { int last = 0; for (int i = 0; i \u0026lt; n; ++i) { if (i != x) { if (nums[i] \u0026lt;= last) { return false; } last = nums[i]; } } return true; }; // find invalid index  for (int i = 1; i \u0026lt; n; ++i) { if (nums[i - 1] \u0026gt;= nums[i]) { return check(i - 1) or check(i); } } return true; } };      Q2. 删除一个字符串中所有出现的给定子字符串   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  数据量较小，暴力即可。\n(TODO: KMP)\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Algorithm: brute-force // Time Complexity: O(n^2), n = s.size() // Space Complexity: O(n) class Solution { public: string removeOccurrences(string s, string part) { string ans; for (auto \u0026amp;\u0026amp;c : s) { ans.push_back(c); if (ans.size() \u0026gt;= part.size() and ans.substr(ans.size() - part.size()) == part) { ans.erase(ans.size() - part.size()); } } return ans; } };      Q3. 最大子序列交替和   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  子序列问题可以考虑用动态规划来进行求解。\n考虑前 i - 1 个数字，维护两个值：\n odd : 长度为奇数时的最大子序列交替和 even : 长度为偶数时的最大子序列交替和  那么对第 i 个数字做决策时，可以得到前 i 个数字对应两个值。\n最终返回 max(odd, even) 即可。\n   代码  1 2 3 4 5 6 7 8 9  # Algorithm: dynamic programming # Time Complexity: O(n), n = len(nums) # Space Complexity: O(1) class Solution: def maxAlternatingSum(self, nums: List[int]) -\u0026gt; int: odd, even = 0, nums[0] for i in range(1, len(nums)): odd, even = max(odd, even - nums[i]), max(even, odd + nums[i]) return max(odd, even)      Q4. 设计电影租借系统   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/design-movie-rental-system/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  明确题意，模拟即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // Algorithm: simulation // Time Complexity: // MovieRentingSystem: O(n \\log n), n = entries.size() // search: O(1) // rent: O(n \\log n) // drop: O(n \\log n) // report: O(1) // Space Complexity: O(n) class MovieRentingSystem { private: //price, shop, movie  set\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; rented; //movie, price, shop  unordered_map\u0026lt;int, set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; movies; // shop, movie -\u0026gt; price  unordered_map\u0026lt;int, unordered_map\u0026lt;int, int\u0026gt;\u0026gt; shopMovie2price; public: MovieRentingSystem(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;entries) { for (auto \u0026amp;\u0026amp;entry : entries) { int shop = entry[0], movie = entry[1], price = entry[2]; movies[movie].emplace(price, shop); shopMovie2price[shop][movie] = price; } } vector\u0026lt;int\u0026gt; search(int movie) { vector\u0026lt;int\u0026gt; ans; for (auto it = movies[movie].begin(); it != movies[movie].end() and ans.size() \u0026lt; 5; ++it) { ans.emplace_back(it-\u0026gt;second); } return ans; } void rent(int shop, int movie) { int price = shopMovie2price[shop][movie]; rented.emplace(price, shop, movie); movies[movie].erase(make_pair(price, shop)); } void drop(int shop, int movie) { int price = shopMovie2price[shop][movie]; rented.erase(make_tuple(price, shop, movie)); movies[movie].emplace(price, shop); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; report() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; for (auto it = rented.begin(); it != rented.end() and ans.size() \u0026lt; 5; ++it) { auto [price, shop, movie] = *it; ans.push_back({shop, movie}); } return ans; } };      注意  合适的变量名以及适当的注释可以让代码写起来清晰很多，思路也不容易出错。\n","date":"Jun 27","permalink":"https://blog.chenjr.top/post/leetcode-biweekly-55/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 55 场双周赛"},{"categories":["周赛"],"contents":"   Q1. 字符串中的最大奇数   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/largest-odd-number-in-string/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  从后往前找到第一个奇数即可。\n   代码  1 2 3 4 5 6 7 8 9  class Solution: def largestOddNumber(self, num: str) -\u0026gt; str: # Algorithm: tranform and conquer # Time Complexity: O(n), n = len(num) # Space Complexity: O(1) for i in range(len(num) - 1, -1, -1): if int(num[i]) % 2 == 1: return num[:i + 1] return \u0026#34;\u0026#34;      Q2. 你完成的完整对局数   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  模拟即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution: # Algorithm: simulation # Time Complexity: O(1) # Space Complexity: O(1) def isOver(self, startHour: int, startMinute: int, finishHour: int, finishMinute: int) -\u0026gt; int: return (startHour * 60 + startMinute) \u0026gt; (finishHour * 60 + finishMinute) def numberOfRounds(self, startTime: str, finishTime: str) -\u0026gt; int: startHour, startMinute = map(int, startTime.split(\u0026#39;:\u0026#39;)) finishHour, finishMinute = map(int, finishTime.split(\u0026#39;:\u0026#39;)) if self.isOver(startHour, startMinute, finishHour, finishMinute): finishHour += 24 if startMinute % 15 != 0: if startMinute \u0026lt; 15: startMinute = 15 elif startMinute \u0026lt; 30: startMinute = 30 elif startMinute \u0026lt; 45: startMinute = 45 else: startHour += 1 startMinute = 0 ans = 0 while True: startMinute += 15 if startMinute \u0026gt;= 60: startHour += 1 startMinute = 0 if self.isOver(startHour, startMinute, finishHour, finishMinute): break ans += 1 return ans      Q3. 统计子岛屿   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/count-sub-islands/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  用深度优先搜索可以找出 grid2 中所有的连通块。\n搜索的同时检查 grid2 中的连通块在 grid1 中是否被完全包含即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution { public: int countSubIslands(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid2) { // Algorithm: dfs  // Time Complexity: O(n * m), n = grid2.size(), m = grid2[0].size()  // Space Complexity: O(1)  int row = grid1.size(), col = grid1[0].size(); constexpr array\u0026lt;pair\u0026lt;int, int\u0026gt;, 4\u0026gt; dir{{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}}; auto check = [\u0026amp;](int x, int y) { return x \u0026gt;= 0 and x \u0026lt; row and y \u0026gt;= 0 and y \u0026lt; col and grid2[x][y] == 1; }; function\u0026lt;bool(int, int)\u0026gt; dfs = [\u0026amp;](int x, int y) { grid2[x][y] = 0; bool valid = grid1[x][y] == 1; for (auto\u0026amp;\u0026amp; [dx, dy] : dir) { if (check(x + dx, y + dy)) { valid \u0026amp;= dfs(x + dx, y + dy); } } return valid; }; int ans = 0; for (int x = 0; x \u0026lt; row; ++x) { for (int y = 0; y \u0026lt; col; ++y) { if (check(x, y) and dfs(x, y)) { ans += 1; } } } return ans; } };      Q4. 查询差绝对值的最小值   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-absolute-difference-queries/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  前缀和 + 计数排序。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution: def minDifference(self, nums: List[int], queries: List[List[int]]) -\u0026gt; List[int]: # Algorithm: prefix sum + counting sort # Time Complexity: O((n + q) * m), n = len(nums), q = len(queries), m = max(nums) # Space Complexity: O(n * m) prefix = [[0] * 101 for _ in range(len(nums) + 1)] for i in range(len(nums)): for j in range(1, 101): prefix[i + 1][j] = prefix[i][j] prefix[i + 1][nums[i]] += 1 ans = list() for left, right in queries: cur = list() for i in range(1, 101): if prefix[right + 1][i] \u0026gt; prefix[left][i]: cur.append(i) if len(cur) == 1: ans.append(-1) else: minimum = inf for i in range(1, len(cur)): minimum = min(minimum, cur[i] - cur[i - 1]) ans.append(minimum) return ans      注意  审题，注意数据范围！\n","date":"Jun 20","permalink":"https://blog.chenjr.top/post/leetcode-weekly-246/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 246 场周赛"},{"categories":["周赛"],"contents":"   Q1. 重新分配字符使所有字符串都相等   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  字符串间的移动是任意的，那么我们只需要统计所有字符出现的次数，检查其是否为 $\\texttt{words.size()}$ 的整数倍即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: bool makeEqual(vector\u0026lt;string\u0026gt;\u0026amp; words) { // Algorithm: transform and conquer  // Time Complexity: O(n), n = sum(len(words[i]))  // Space Complexity: O(1)  array\u0026lt;int, 26\u0026gt; cnt{}; for (auto\u0026amp;\u0026amp; word : words) { for (auto\u0026amp;\u0026amp; ch : word) { cnt[ch - \u0026#39;a\u0026#39;] += 1; } } int n = static_cast\u0026lt;int\u0026gt;(words.size()); for (auto\u0026amp;\u0026amp; c : cnt) { if (c % n != 0) { return false; } } return true; } };      Q2. 可移除字符的最大数目   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-number-of-removable-characters/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  很容易想到暴力的做法，即直接使用双指针进行模拟，时间复杂度是 $\\texttt{O((s.size() + p.size()) * removable.size())}$，其计算量级会达到 $10^{10}$，显然无法通过本题。\n观察到对于 $\\texttt{removable}$ 的选择具有单调性，当我们移除前 $\\texttt{x(x \u0026lt; k)}$ 个字符时，$\\texttt{p}$ 一定仍然是 $\\texttt{s}$ 的一个子序列；当我们移除前 $\\texttt{y(y \u0026gt; k)}$ 个字符时，$\\texttt{p}$ 一定不是 $\\texttt{s}$ 的一个子序列。\n那么我们可以使用二分的方法，使得时间复杂度降为 $\\texttt{O((s.size() + p.size()) * log removable.size())}$，可以通过本题。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution { public: int maximumRemovals(string s, string p, vector\u0026lt;int\u0026gt;\u0026amp; removable) { // Algorithm: binary search + two pointer  // Time Complexity: O((n + m) * log r), n = len(s), m = len(p), r = len(removable)  // Space Complexity: O(n)  int n = static_cast\u0026lt;int\u0026gt;(s.size()), m = static_cast\u0026lt;int\u0026gt;(p.size()); auto check = [\u0026amp;](int k) { vector\u0026lt;bool\u0026gt; removed(n); for (int i = 0; i \u0026lt; k; ++i) { removed[removable[i]] = true; } int i = 0, j = 0; while (i \u0026lt; n and j \u0026lt; m) { if (not removed[i] and s[i] == p[j]) { j += 1; } i += 1; } return j == m; }; int low = 0, high = static_cast\u0026lt;int\u0026gt;(removable.size()); while (low \u0026lt; high) { int mid = (low + high + 1) / 2; if (check(mid)) { low = mid; } else { high = mid - 1; } } return low; } };      Q3. 合并若干三元组以形成目标三元组   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  观察到 $triplets[i] = [a_i, b_i, c_i]$ 中若 $a_i \u0026gt; x$ 或 $b_i \u0026gt; y$ 或 $c_i \u0026gt; z$，那么 $triplets[i]$ 将是无效的，也即我们不需要使用到 $triplets[i]$ 以得到最终的结果。\n而在 $\\texttt{triplets}$ 剩余的三元组中，我们只需要找到三个位置的最大值，检查他们是否与 $\\texttt{target}$ 一一对应即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -\u0026gt; bool: # Algorithm: transform and conquer # Time Complexity: O(n), n = len(triplets) # Space Complexity: O(1) x, y, z = target u = v = w = -inf for a, b, c in triplets: if a \u0026lt;= x and b \u0026lt;= y and c \u0026lt;= z: u = max(u, a) v = max(v, b) w = max(w, c) return (u, v, w) == (x, y, z)      Q4. 最佳运动员的比拼回合   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路   参考 @吴自华\n 观察到数据量很小，考虑状压DP，枚举每场比赛的胜负，同时用一个 $\\texttt{pair}$ 标记当前两个运动员的位置作为状态。\n但是直接进行状压DP将会是 $2^{28}$ 的计算量级，显然不符合要求。\n观察到第一轮之后就只会剩下一半（$28 / 2 = 14$）的运动员，那么我们状压DP的计算量级只会达到 $2^{14} \u0026lt; 2 * 10^4$。\n到第二轮时，两个运动员可能的位置只有（$ 14 * 13 = 182$）种情况，此时状压DP的计算量级为 $182 * 2^7 \u0026lt; 3 * 10^4$。\n到第三轮，此时仅有（$14 / 2 = 7$）名运动员。两个运动员可能的位置只有（$ 7 * 6 = 42$）种情况，此时状压DP的计算量级为 $42 * 2^3 \u0026lt; 1 * 10^3$。\n到第四轮，此时仅有（$7 / 2 = 4$）名运动员。两个运动员可能的位置只有（$ 4 * 3 = 12$）种情况，此时状压DP的计算量级为 $12 * 2^2 \u0026lt; 1 * 10^2$。\n到第五轮，此时仅有（$4 / 2 = 2$）名运动员。两个运动员可能的位置只有两种情况，此时状压DP的计算量级为 $2 * 2^1 \u0026lt; 1 * 10^1$。\n由此可见，暴力枚举的计算量级在 $10^5$ 级别，可以通过本题。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  class Solution { public: vector\u0026lt;int\u0026gt; earliestAndLatest(int n, int firstPlayer, int secondPlayer) { // Algorithm: dynamic programming  // Time Complexity: O(n * 2^(n / 2))  // Space Complexity: O(n^2)  set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; states{{firstPlayer, secondPlayer}}; int earliest = numeric_limits\u0026lt;int\u0026gt;::max(), latest = 0, round = 1; while (not states.empty()) { set\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; newStates; for (auto\u0026amp;\u0026amp; [first, second] : states) { if (first + second == n + 1) { earliest = min(earliest, round); latest = max(latest, round); } else { int player = n / 2; for (int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; player); ++mask) { set\u0026lt;int\u0026gt; winner; for (int i = 0; i \u0026lt; player; ++i) { if ((mask \u0026gt;\u0026gt; i) \u0026amp; 1) { winner.emplace(i + 1); } else { winner.emplace(n - i); } } if (n % 2 == 1) { winner.emplace((n + 1) / 2); } if (winner.find(first) != winner.end() and winner.find(second) != winner.end()) { int firstPlace = -1, secondPlace = -1, i = 1; auto it = winner.begin(); while (firstPlace == -1 or secondPlace == -1) { if (*it == first) { firstPlace = i; } else if (*it == second) { secondPlace = i; } ++i; ++it; } newStates.emplace(firstPlace, secondPlace); } } } } states = move(newStates); n = (n + 1) / 2; round += 1; } return {earliest, latest}; } };      注意  运动员的编号不要弄错了\n","date":"Jun 15","permalink":"https://blog.chenjr.top/post/leetcode-weekly-245/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 245 场周赛"},{"categories":["周赛"],"contents":"   Q1. 检查是否区域内所有整数都被覆盖   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  模拟\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -\u0026gt; bool: # Algorithm: simulation # Time Complexity: O(n * m), n = right - left + 1, m = len(ranges) # Space Complexity: O(1) for cur in range(left, right + 1): ok = False for begin, end in ranges: if begin \u0026lt;= cur \u0026lt;= end: ok = True break if not ok: return False return True      Q2. 找到需要补充粉笔的学生编号   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  模拟可以发现，重复的循环其实可以通过取模来简化。\n   代码  1 2 3 4 5 6 7 8 9 10 11  class Solution: def chalkReplacer(self, chalk: List[int], k: int) -\u0026gt; int: # Algorithm: simulation # Time Complexity: O(n), n = len(chalk) # Space Complexity: O(1) k %= sum(chalk) for i, c in enumerate(chalk): k -= c if k \u0026lt; 0: return i return 0      Q3. 最大的幻方   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/largest-magic-square/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  前缀和。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  class Solution { public: int largestMagicSquare(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { // Algorithm: prefix sum  // Time Complexity: O(n * m * p * q), n = grid.size(), m = grid[0].size(), p = min(n, m), q = max(n, m)  // Space Complexity: O(n * m)  int row = static_cast\u0026lt;int\u0026gt;(grid.size()), col = static_cast\u0026lt;int\u0026gt;(grid[0].size()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; rowSum(row, vector\u0026lt;int\u0026gt;(col + 1)), colSum(row + 1, vector\u0026lt;int\u0026gt;(col)); for (int x = 0; x \u0026lt; row; ++x) { for (int y = 0; y \u0026lt; col; ++y) { rowSum[x][y + 1] = rowSum[x][y] + grid[x][y]; colSum[x + 1][y] = colSum[x][y] + grid[x][y]; } } for (int i = min(row, col); i \u0026gt;= 2; --i) { for (int x = 0; x + i \u0026lt;= row; ++x) { for (int y = 0; y + i \u0026lt;= col; ++y) { // [x, y] =\u0026gt; [x + i - 1, y + i - 1]  int diagSum = 0, subSum = 0; for (int t = 0; t \u0026lt; i; ++t) { diagSum += grid[x + t][y + t]; subSum += grid[x + t][y + i - 1 - t]; } if (diagSum != subSum) { continue; } bool ok = true; for (int t = x; t \u0026lt; x + i and ok; ++t) { if (rowSum[t][y + i] - rowSum[t][y] != diagSum) { ok = false; } } for (int t = y; t \u0026lt; y + i and ok; ++t) { if (colSum[x + i][t] - colSum[x][t] != diagSum) { ok = false; } } if (ok) { return i; } } } } return 1; } };      Q4. 反转表达式值的最少操作次数   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-cost-to-change-the-final-value-of-expression/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路   参考 @吴自华\n 栈 + 动态规划\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Solution { public: int minOperationsToFlip(string expression) { // Algorithm: stack + dynamic programming  // Time Complexity: O(n), n = expression.size()  // Space Complexity: O(n), n = expression.size()  stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; states; stack\u0026lt;char\u0026gt; ops; // possible ch : \u0026#39;()10|\u0026amp;\u0026#39;  for (auto\u0026amp;\u0026amp; ch : expression) { if (ch == \u0026#39;0\u0026#39; or ch == \u0026#39;1\u0026#39; or ch == \u0026#39;)\u0026#39;) { if (ch == \u0026#39;)\u0026#39;) { ops.pop(); } else { states.emplace(ch - \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39; - ch); } if (not ops.empty() and (ops.top() == \u0026#39;|\u0026#39; or ops.top() == \u0026#39;\u0026amp;\u0026#39;)) { auto op = ops.top(); ops.pop(); auto [right0, right1] = states.top(); states.pop(); auto [left0, left1] = states.top(); states.pop(); int ans0 = 0, ans1 = 0; if (op == \u0026#39;|\u0026#39;) { states.emplace(min(left0 + right0, min(left0, right0) + 1), min(left1, right1)); } else { states.emplace(min(left0, right0), min(left1 + right1, min(left1, right1) + 1)); } } } else { ops.emplace(ch); } } auto [ans0, ans1] = states.top(); return ans0 == 0 ? ans1 : ans0; } };   ","date":"Jun 13","permalink":"https://blog.chenjr.top/post/leetcode-biweekly-54/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 54 场双周赛"},{"categories":["面试"],"contents":"   剑指 Offer 03. 数组中重复的数字   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  原地哈希。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13  // Algorithm: hash in-place // Time Complexity: O(n), n = len(nums) // Space Complexity: O(1) func findRepeatNumber(nums []int) int { n := len(nums) for i := range nums { if nums[nums[i]%n] \u0026gt;= n { return nums[i] % n } nums[nums[i]%n] += n } return -1 }      剑指 Offer 04. 二维数组中的查找   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  从数组的右上或左下开始查找，可以有效地进行减治。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution { public: bool Find(int target, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; array) { // Corner Case:  if (array.empty() or array.front().empty()) { return false; } // Normal Case:  int n = static_cast\u0026lt;int\u0026gt;(array.size()); int x = 0, y = n - 1; while (x \u0026lt; n and y \u0026gt;= 0) { if (array[x][y] == target) { return true; } if (array[x][y] \u0026lt; target) { x += 1; } else { y -= 1; } } return false; } };      剑指 Offer 05. 替换空格   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  用 strings.Builder。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Algorithm: copy // Time Complexity: O(n), n = len(s) // Space Complexity: O(n) func replaceSpace(s string) string { // return strings.ReplaceAll(s, \u0026#34; \u0026#34;, \u0026#34;%20\u0026#34;) \tsb := \u0026amp;strings.Builder{} sb.Grow(3 * len(s)) for i := range s { if s[i] == \u0026#39; \u0026#39; { sb.WriteString(\u0026#34;%20\u0026#34;) } else { sb.WriteByte(s[i]) } } return sb.String() }      剑指 Offer 06. 从尾到头打印链表   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  正向遍历，反转数组。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // Algorithm: traverse and reverse // Time Complexity: O(n), n = len(List) // Space Complexity: O(n) func reversePrint(head *ListNode) []int { ans := []int{} // traverse \tfor curr := head; curr != nil; curr = curr.Next { ans = append(ans, curr.Val) } // reverse \tfor i, j := 0, len(ans)-1; i \u0026lt; j; i, j = i+1, j-1 { ans[i], ans[j] = ans[j], ans[i] } return ans }      剑指 Offer 09. 用两个栈实现队列   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  使用两个栈，交替 push 及 pop 实现队列。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // Algorithm: double stacks // Time Complexity: O(1) // Space Complexity: O(n), n = len(data) type CQueue struct { stk1, stk2 []int } func Constructor() CQueue { return CQueue{} } func (this *CQueue) AppendTail(value int) { this.stk1 = append(this.stk1, value) } func (this *CQueue) DeleteHead() int { // Corner case \tif len(this.stk1) == 0 \u0026amp;\u0026amp; len(this.stk2) == 0 { return -1 } // Pop stack 1 into stack 2 \tif len(this.stk2) == 0 { for len(this.stk1) \u0026gt; 0 { this.stk2 = append(this.stk2, this.stk1[len(this.stk1)-1]) this.stk1 = this.stk1[:len(this.stk1)-1] } } // return result \tresult := this.stk2[len(this.stk2)-1] this.stk2 = this.stk2[:len(this.stk2)-1] return result }      剑指 Offer 11. 旋转数组的最小数字   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  二分查找，分类讨论。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // Algorithm: binary search // Time Complexity: n = len(nums) //\tAverage: O(log n) //\tWorst: O(n) // Space Complexity: n = len(nums) //\tAverage: O(1) //\tWorst: O(log n) func minArray(nums []int) int { var search func(left, right int) int search = func(left, right int) int { // Corner Case \tif left \u0026gt; right { return math.MaxInt32 } if left == right || nums[left] \u0026lt; nums[right] { // return first element \treturn nums[left] } mid := left + (right-left)/2 if nums[left] == nums[right] { if nums[mid] == nums[left] { // nums[left] == nums[mid] == nums[right] \tminimum := nums[mid] if lhs := search(left, mid-1); lhs \u0026lt; minimum { minimum = lhs } if rhs := search(mid+1, right); rhs \u0026lt; minimum { minimum = rhs } return minimum } if nums[mid] \u0026lt; nums[left] { // nums[mid] \u0026lt; nums[left] == nums[right] \treturn search(left, mid) } // nums[left] == nums[right] \u0026lt; nums[mid] \treturn search(mid+1, right) } // nums[left] \u0026gt; nums[right] \tif nums[mid] \u0026gt;= nums[left] { return search(mid+1, right) } return search(left, mid) } return search(0, len(nums)-1) }      剑指 Offer 24. 反转链表   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  使用辅助的指针，迭代反转。必要时可以画图，辅助理解。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13  // Algorithm: iterate // Time Complexity: O(n), n = len(List) // Space Complexity: O(1) func reverseList(head *ListNode) *ListNode { var prev *ListNode for head != nil { next := head.Next head.Next = prev prev = head head = next } return prev }      剑指 Offer 26. 树的子结构   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  $O(n^2)$ 搜索。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Algorithm: dfs // Time Complexity: O(n^2), n = tree.size() // Space Complexity: O(log n) func check(A, B *TreeNode) bool { if B == nil { return true } if A == nil || A.Val != B.Val { return false } return check(A.Left, B.Left) \u0026amp;\u0026amp; check(A.Right, B.Right) } func isSubStructure(A, B *TreeNode) bool { if A == nil || B == nil { return false } if check(A, B) { return true } return isSubStructure(A.Left, B) || isSubStructure(A.Right, B) }      剑指 Offer 27. 二叉树的镜像   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  深搜。\n   代码  1 2 3 4 5 6 7 8 9 10 11  // Algorithm: dfs // Time Complexity: O(n), n = tree.size() // Space Complexity: O(log n) func mirrorTree(root *TreeNode) *TreeNode { if root != nil { root.Left, root.Right = root.Right, root.Left mirrorTree(root.Left) mirrorTree(root.Right) } return root }      剑指 Offer 28. 对称的二叉树   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  深搜。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // Algorithm: dfs // Time Complexity: O(n), n = tree.size() // Space Complexity: O(log n) func isSymmetric(root *TreeNode) bool { if root == nil { return true } var check func(a, b *TreeNode) bool check = func(a, b *TreeNode) bool { if (a == nil) != (b == nil) { return false } if a == nil { return true } if a.Val != b.Val { return false } return check(a.Left, b.Right) \u0026amp;\u0026amp; check(a.Right, b.Left) } return check(root.Left, root.Right) }      剑指 Offer 30. 包含min函数的栈   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  双栈思路，保持栈中每个元素在 min 栈中对应当前最小值。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // Algorithm: double stacks // Time Complexity: O(1) // Space Complexity: O(n), n = len(data) type MinStack struct { stk, min []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(x int) { this.stk = append(this.stk, x) if len(this.min) == 0 || x \u0026lt;= this.min[len(this.min)-1] { this.min = append(this.min, x) } } func (this *MinStack) Pop() { if this.stk[len(this.stk)-1] == this.min[len(this.min)-1] { this.min = this.min[:len(this.min)-1] } this.stk = this.stk[:len(this.stk)-1] } func (this *MinStack) Top() int { return this.stk[len(this.stk)-1] } func (this *MinStack) Min() int { return this.min[len(this.min)-1] }      剑指 Offer 32 - I. 从上到下打印二叉树   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  层序遍历。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // Algorithm: level order traverse // Time Complexity: O(n), n = tree.size() // Space Complexity: O(n) func levelOrder(root *TreeNode) []int { ans := []int{} q := []*TreeNode{} if root != nil { q = append(q, root) } for len(q) \u0026gt; 0 { for _, cur := range q { q = q[1:] ans = append(ans, cur.Val) if cur.Left != nil { q = append(q, cur.Left) } if cur.Right != nil { q = append(q, cur.Right) } } } return ans }      剑指 Offer 32 - II. 从上到下打印二叉树 II   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  层序遍历。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Algorithm: level order traverse // Time Complexity: O(n), n = tree.size() // Space Complexity: O(n) func levelOrder(root *TreeNode) [][]int { ans := [][]int{} q := []*TreeNode{} if root != nil { q = append(q, root) } for len(q) \u0026gt; 0 { res := []int{} for _, cur := range q { q = q[1:] res = append(res, cur.Val) if cur.Left != nil { q = append(q, cur.Left) } if cur.Right != nil { q = append(q, cur.Right) } } ans = append(ans, res) } return ans }      剑指 Offer 32 - III. 从上到下打印二叉树 III   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  层序遍历。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // Algorithm: level order traverse // Time Complexity: O(n), n = tree.size() // Space Complexity: O(n) func levelOrder(root *TreeNode) [][]int { ans := [][]int{} q := []*TreeNode{} if root != nil { q = append(q, root) } for len(q) \u0026gt; 0 { res := []int{} for _, cur := range q { q = q[1:] res = append(res, cur.Val) if cur.Left != nil { q = append(q, cur.Left) } if cur.Right != nil { q = append(q, cur.Right) } } if len(ans)\u0026amp;1 \u0026gt; 0 { for i, j := 0, len(res)-1; i \u0026lt; j; i, j = i+1, j-1 { res[i], res[j] = res[j], res[i] } } ans = append(ans, res) } return ans }      剑指 Offer 35. 复杂链表的复制   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  类似原地哈希。在并发的场景下，需要借助额外的空间。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // Algorithm: hash in place // Time Complexity: O(n), n = len(List) // Space Complexity: O(1) func copyRandomList(head *Node) *Node { // Copy each node(without `random`) in place \tfor curr := head; curr != nil; curr = curr.Next.Next { duplicate := Node{Val: curr.Val, Next: curr.Next} curr.Next = \u0026amp;duplicate } // Copy `random` \tfor curr := head; curr != nil; curr = curr.Next.Next { if curr.Random != nil { curr.Next.Random = curr.Random.Next } } // Separate \tdummy := Node{} curr := \u0026amp;dummy for head != nil { curr.Next = head.Next head.Next = head.Next.Next curr = curr.Next head = head.Next } return dummy.Next }      剑指 Offer 50. 第一个只出现一次的字符   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  哈希表，两次遍历。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Algorithm: hash table // Time Complexity: O(n), n = len(s) // Space Complexity: O(1) func firstUniqChar(s string) byte { cnt := [26]int{} for i := range s { cnt[s[i]-\u0026#39;a\u0026#39;] += 1 } for i := range s { if cnt[s[i]-\u0026#39;a\u0026#39;] == 1 { return s[i] } } return \u0026#39; \u0026#39; }      剑指 Offer 53 - I. 在排序数组中查找数字 I   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  二分查找。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // Algorithm: binary search // Time Complexity: O(log n), n = len(nums) // Space Complexity: O(1) func search(nums []int, target int) int { binarySearch := func(lower bool) int { low, high := 0, len(nums)-1 for low \u0026lt; high { mid := (low + high + 1) / 2 if lower { mid = (low + high) / 2 } if nums[mid] == target { if lower { high = mid } else { low = mid } } else if nums[mid] \u0026lt; target { low = mid + 1 } else { high = mid - 1 } } return low } left := binarySearch(true) if left \u0026gt;= len(nums) || nums[left] != target { return 0 } right := binarySearch(false) return right - left + 1 }      剑指 Offer 53 - II. 0～n-1中缺失的数字   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  通过数字交换实现原地哈希。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Algorithm: hash in-place // Time Complexity: O(n), n = len(nums) // Space Complexity: O(1) func missingNumber(nums []int) int { for i := range nums { for nums[i] != i \u0026amp;\u0026amp; nums[i] != len(nums) { nums[nums[i]], nums[i] = nums[i], nums[nums[i]] } } for i := range nums { if nums[i] != i { return i } } return len(nums) }      剑指 Offer 58 - II. 左旋转字符串   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  切片。\n   代码  1 2 3 4 5 6  // Algorithm: slice // Time Complexity: O(n), n = len(s) // Space Complexity: O(n) func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] }      JZ16. 合并两个排序的链表   来源：力扣（LeetCode）\n链接：[]\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  允许对原链表进行修改的话，由于 next 指针可以变化，那么对于已经排好序的节点我们可以不用考虑了。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // Algorithm: decrease and conquer // Time Complexity: O(n + m), n = len(pHead1), m = len(pHead2) // Space Complexity: O(1) class Solution { public: ListNode *Merge(ListNode *pHead1, ListNode *pHead2) { ListNode dummy(0); auto curr = \u0026amp;dummy; while (pHead1 != nullptr and pHead2 != nullptr) { if (pHead1-\u0026gt;val \u0026lt; pHead2-\u0026gt;val) { curr-\u0026gt;next = pHead1; pHead1 = pHead1-\u0026gt;next; } else { curr-\u0026gt;next = pHead2; pHead2 = pHead2-\u0026gt;next; } curr = curr-\u0026gt;next; } if (pHead1 != nullptr) { curr-\u0026gt;next = pHead1; } else { curr-\u0026gt;next = pHead2; } return dummy.next; } };      JZ53. 表示数值的字符串   来源：力扣（LeetCode）\n链接：[]\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  对于这种比较复杂的状态转移，硬编码 if-else 会使得逻辑复杂，难以扩展；更好的方式是使用确定有限状态自动机 DFA。\n这里我们先定义可能出现的几种符号所属类型：\n   字符 类型     ‘+’ / ‘-’ 0   ‘0’ ~ ‘9’ 1   ‘.’ 2   ‘e’ / ‘E’ 3   others -1    那么，我们可以根据题意得到以下状态转移图：\n 参考状态转移图，我们可以得出以下状态转移矩阵：\n   状态／字符类型 type0 type1 type2 type3     state0 state1 state2 state3 state0   state1 state0 state2 state3 state0   state2 state0 state2 state3 state5   state3 state0 state4 state0 state5   state4 state0 state4 state0 state5   state5 state6 state7 state0 state0   state6 state0 state7 state0 state0   state7 state0 state7 state0 state0    说明：\n 0 为初始状态，如果从其他任意状态又回到了初始状态，我们将其标记为不合法的字符串。 2, 4, 7 为合法的结束状态。     代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  class Solution { public: bool isNumeric(string str) { // Algorithm: dfa  // Time Complexity: O(n), n = str.size()  // Space Complexity: O(1)  // [+/-, 0..9, ., e/E]  constexpr static array\u0026lt;array\u0026lt;int, 4\u0026gt;, 8\u0026gt; transfer{ {{1, 2, 3, 0}, {0, 2, 3, 0}, {0, 2, 3, 5}, {0, 4, 0, 5}, {0, 4, 0, 5}, {6, 7, 0, 0}, {0, 7, 0, 0}, {0, 7, 0, 0}}}; auto char2type = [](const char\u0026amp; ch) { if (ch == \u0026#39;+\u0026#39; or ch == \u0026#39;-\u0026#39;) { return 0; } if (isdigit(ch)) { return 1; } if (ch == \u0026#39;.\u0026#39;) { return 2; } if (ch == \u0026#39;e\u0026#39; or ch == \u0026#39;E\u0026#39;) { return 3; } return -1; }; int state = 0; for (auto\u0026amp;\u0026amp; ch : str) { int type = char2type(ch); if (type == -1) { return false; } state = transfer[state][type]; if (state == 0) { return false; } } return state == 2 or state == 4 or state == 7; } };   ","date":"Jun 10","permalink":"https://blog.chenjr.top/post/sword-to-offer/","tags":["Algorithm"],"title":"剑指 offer"},{"categories":["周赛"],"contents":"   Q1. 判断矩阵经轮转后是否一致   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  容易发现，旋转四次 mat 即回到了原始状态。\n所以我们只需要至多旋转三次 mat ，每次判断是否和 target 一致即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: bool findRotation(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; target) { // Algorithm: simulation  // Time Complexity: O(n^2), n = mat.size()  // Space Complexity: O(n^2), n = mat.size()  // Corner Case:  if (mat == target) return true; // Normal Case:  int n = static_cast\u0026lt;int\u0026gt;(mat.size()); auto rotate = [\u0026amp;]() { auto rotation = mat; for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n; ++j) rotation[j][n - i - 1] = mat[i][j]; mat = move(rotation); }; for (int _ = 0; _ \u0026lt; 3; ++_) { rotate(); if (mat == target) return true; } return false; } };      Q2. 使数组元素相等的减少操作次数   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  使用 map 来模拟这一过程即可。\nmap 可以带上自定义的排序规则，使用 greater\u0026lt;\u0026gt; 使得 map 逆序，更加方便。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution { public: int reductionOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // Algorithm: simulation  // Time Complexity: O(n log n), n = nums.size()  // Space Complexity: O(n)  map\u0026lt;int, int, greater\u0026lt;\u0026gt;\u0026gt; mp; for (auto\u0026amp;\u0026amp; num : nums) mp[num] += 1; int ans = 0, tot = 0; for (auto\u0026amp;\u0026amp; [num, cnt] : mp) { ans += tot; tot += cnt; } return ans; } };      Q3. 使二进制字符串字符交替的最少反转次数   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  遇到这种多种类型操作的问题，尽量地去把操作简化为一种。\n对于类型 1 的操作，我们可以使用 T = S + S 的方法进行模拟。\n对于类型 2 的操作，结合最终所需要的交替字符串，很容易想到只有两种交替情况，枚举即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution { public: int minFlips(string s) { // Algorithm: sliding windows  // Time Complexity: O(n), n = s.size()  // Space Complexity: O(1)  // Possible Cases:  // 0101...  // 1010...  int n = static_cast\u0026lt;int\u0026gt;(s.size()); int cnt0 = 0, cnt1 = 0, ans = n; s += s; for (int i = 0; i \u0026lt; 2 * n; ++i) { if (i \u0026gt;= n) { if (s[i - n] != ((i - n) % 2) + \u0026#39;0\u0026#39;) cnt0 -= 1; else cnt1 -= 1; } if (s[i] != (i % 2) + \u0026#39;0\u0026#39;) cnt0 += 1; else cnt1 += 1; if (i \u0026gt;= n - 1) ans = min({ans, cnt0, cnt1}); } return ans; } };      Q4. 装包裹的最小浪费空间   来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-space-wasted-from-packaging/\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n    思路  遍历每个供应商，将其提供的箱子进行排序，贪心选择尽可能小的箱子装包裹。\n在遍历之前，我们提前计算好 packages 的前缀和；遍历过程中，借助前缀和计算浪费的空间即可。\n   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  using ull = unsigned long long; class Solution { public: int minWastedSpace(vector\u0026lt;int\u0026gt;\u0026amp; packages, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; boxes) { // Algorithm: greed  // Time Complexity: O(m log m + m log n + n log n), n = packages.size(), m = sum(boxes[i].size())  // Space Complexity: O(n), n = packages.size()  int n = static_cast\u0026lt;int\u0026gt;(packages.size()); sort(begin(packages), end(packages)); vector\u0026lt;ull\u0026gt; prefix(n + 1); for (int i = 0; i \u0026lt; n; ++i) prefix[i + 1] = prefix[i] + packages[i]; ull ans = numeric_limits\u0026lt;ull\u0026gt;::max(); for (auto\u0026amp;\u0026amp; box : boxes) { ull last = 0, res = 0; sort(begin(box), end(box)); if (box.back() \u0026lt; packages.back()) continue; for (auto\u0026amp;\u0026amp; b : box) { auto curr = upper_bound(begin(packages), end(packages), b) - begin(packages); res += (curr - last) * b - (prefix[curr] - prefix[last]); last = curr; if (last \u0026gt;= n) break; } ans = min(ans, res); } return ans == numeric_limits\u0026lt;ull\u0026gt;::max() ? -1 : ans % 1\u0026#39;000\u0026#39;000\u0026#39;007; } };   ","date":"Jun 09","permalink":"https://blog.chenjr.top/post/leetcode-weekly-244/","tags":["LeetCode","Competitive Programming","Algorithm"],"title":"LeetCode 第 244 场周赛"},{"categories":["保研"],"contents":"   前期准备  准备的内容其实无非也就是面试、机试：\n 面试部分主要围绕英语口语以及听力、数学课、专业课和项目展开。具体的内容比较个性化，准备的话我推荐看一些市面上 关于程序员面试类的书籍 ，可以覆盖很大一部分关键的专业课知识，当然如果基础比较扎实的话，把自己学过的知识重新复习一遍是最好的啦。 机试部分主要就是算法题啦。我参考的书是 《王道论坛计算机考研机试指南》，这本书特别适合拿来入门机试，从头到尾刷完这本书的话应付大部分院校的机试基本没有什么问题了。另外可以提前去考一些院校认可的证书，在机试时可以抵分，比如 CSP 1、 PAT 2。  另外关于保研的资料搜集，也是很重要的工作，几个大的问题大概提一下：\n   方向选择  保研可以跨保，但是我个人是没有考虑过其他专业，本文也主要围绕计算机专业展开。\n   院校申请  能不能过夏令营或九推的初审，和自身的本科出身、成绩、科研、竞赛以及有否联系老师等诸多因素有关。九推难度一般会比夏令营小的多，如果夏令营被拒也不要气馁，九推还有机会，就算九推也凉，也注意留意短信电话邮件等，特别是快填系统那几天，鸽子满天飞，没有 offer 的就可以捡漏。每年的夏令营，热门院校的预录取名单都会有一部分交集，不少的人手里拿着不止一个 offer ，所以竞争就会激烈一些。我个人的建议是，拿到更好的 offer 就可以把其他的拒了，手里拿着一个保证有书读就行，太晚拒的话，对导师、学校、候补的同学、学弟学妹都会有影响。最后关于申请方面，这里列出来一些我没有通过初审的学校：\n 清华计算机软院叉院、北大信科叉院、上交电院、南大LAMDA、中科院自动化所计算所 3 南大计算机 4 复旦计算机、同济计算机、武大计算机、中科院软件所、哈工大深圳、华科计算机 5     联系导师  我的入营除了清华深研院，其他学校都没有提前联系老师。不懒的话都提前联系一下是最好的，我就有些懒得花时间在这上面。很多学校被拒一部分原因可能就是没有提前联系老师，当然大部分原因应该还是本科出身以及自身实力不够。导师的信息可以在学校官网上找，看到合适的，可以到 谷歌学术 上了解他的学术水平，在 导师评价网 上了解为人，综合自己的实力选择一个合适的导师去联系。\n   硕士／直博  我参加的夏令营全部报的都是硕士项目。需要特别提醒的是，慎报直博，除非自己有强烈的读博意愿以及确定导师的人品、学术水平等没有问题 6，否则个人不是很推荐。想要了解更多的话可以参考：为什么现在有些研究生想退学？。\n   保研经历  因为过审的夏令营时间都基本错开了，所以我参加的夏令营算是比较多的。\n   南开大学人工智能学院 人工智能方向   时间：6月8日 — 6月9日。 安排：第一天参观，第二天面试。 面试内容：  中文自我介绍 聊了会项目，没有问具体的问题 问来南开的概率多大 最后一个英文问题：Do you like TianJin？    这是我参加的第一个夏令营，基本费用学校都给报销，学校环境也很舒服。前一天晚上在酒店背了很久的英文介绍，没想到第二天就只用中文。考核感觉特别简单，只有面试，而且没有具体的问题，面试全程更像是在聊天，老师也很 nice ，最后给我打了个很高的面试分。问过其他一些同学的情况，还有用英文介绍项目的，黑板写公式的，就比我硬核很多，可能面试还是有点看运气吧。\n后面需要拿着面试成绩去联系老师，我联系的老师说需要确定去才给 offer ，当时有几个夏令营也通知说过了初审，想着去南开概率也不大，在6月底就放弃了南开。\n   中国人民大学高瓴人工智能学院 人工智能方向   时间：7月5日 — 7月7日 安排：第一天下午报道，第二天早上参观，下午笔试+机试，第三天早上面试。 笔试：两小时三道大题，C语言，手写代码，不允许用 STL 。  用三种循环实现 strncpy 二叉树按层次遍历，从底往上输出结果 7 文件操作：文件里有 $n$ 个数，可能有重复，输出按出现先后顺序整合后的结果，比如：$400, 20, 30, 400, 20$ ，就输出 $400, 400, 20, 20, 30$ 。设计算法，说明可以改进的地方以及时空复杂度。 8   机试：在 POJ 上考，可以看到实时 rank 以及 AC 情况，两道题四十分钟。  输出斐波那契数列 9 大整数的进制转换 10   面试：黑盒面试，不允许递简历，还有摄像头录像，非常公平公正。  英文群面：八个人一组，自我介绍 + 老师单问每个人一个简单的英文问题，记得的有：为什么选择人大？最喜欢的科目？为什么喜欢？有什么爱好？ 中文单面：时间很短，好像我五分钟多一点就出来了。  最喜欢哪门课？然后展开聊了一下。 问我的竞赛，说说算法，思路之类的。这里我自己扯了很久，好像把时间扯完了，老师就没问什么了。      夏令营体验非常棒，尽管就在一条街，也提供校内住宿，100饭卡，送了很多很好看的纪念品，特别用心。人大真的很棒，尽管学科评估计算机只是 B+ 的评级，但是经历过推免之后，感觉单看学科评估评价一个学校其实挺蠢的。高瓴有一些很厉害的导师，如果能跟到他们读研究生的话，其实还是蛮不错的啦。\n总的来说，想去人大的话需要提前准备一下笔试（很独特的考核），机试最好满分，面试的话感觉老师都很 nice ，别有压力基本没有什么问题。大概在7月中旬出来结果，人大人工智能学院硕士只要六个外校的，我排在候补第三位，在七月下旬的时候招生办电话说候补录到我了，当时已经拿到了北航的 offer，一方面还想在九推试试其他学校（人大没有九推，接受了就提前结束保研之旅了），所以就拒了。\n   北京理工大学计算机学院 计算机科学与技术   时间：7月8日 — 7月10日 安排：第一天下午报道，第二天早上参观，下午机试，第三天早上面试。 机试：两道题，人工测，老师手上有几个案例以及答案，没有时间、内存限制，只要结果是对的就行。  最最基础朴素的 BFS 三个字符串 $a, b, c$ ，问 $c$ 可以由几个 $a$ 和几个 $b$ 共同组成   面试：  中文自我介绍 问项目，也是像聊天一样 两个英文问题，想读硕士还是博士，工作想去企业还是留高校    面试完很多老师有和我联系，当时就和一个老师说清楚可能不会去北理，然后他也愿意给我留名额，也算是有了个保底 offer 。\n   北京航空航天大学计算机学院 计算机科学与技术   时间：7月11日 — 7月14日 安排：第一天早上报道，下午分两批机试，第二天第三天分两批面试，第三天晚上就公布优秀营员名单，第四天找自己想去的导师签字。 机试：两小时两道题。提交代码之后只显示编译结果，不知道正确与否。  $n$ 个数排成一个环，每次取出最小的数，输出经过的数字 给定后缀表达式，求中缀表达式（带括号）并计算结果   面试：计时二十分钟，到时间才结束  英文自我介绍 政治——习近平：奋斗是青春最亮丽的底色，谈谈你对奋斗的认识 英语——一篇英文短文的朗读与翻译，我抽到的是关于 DVB 的 数学——问了线性空间，欧拉图，哈密顿图，二项分布，正态分布，泊松分布，详细解释二项分布 最喜欢哪一门课，我答的数据结构 —— 问了红黑树，完全二叉树和满二叉树，最小生成树的两种算法，详细说一下 Prim 算法 计算机网络——如何求两个节点在信道里面的最长距离？    北航入营600人左右，机试刷一半人，面试再刷一半人。机试我当时第一题就花了不到二十分钟，后面一个小时四十分钟都在想第二题，顶不住代码功底太差，最后也没写出来，机试只要一题就能过，没有把握的话建议稳住第一道，别学我差点就爆零了。最后优秀营员会按机试面试加权分进行排名，如果机试 AK 的话会很有优势（我们这一届排名前40才有学硕）。面试感觉年年都是那几个问题，熟悉套路的话答起来会很轻松。所以说想去北航的话，代码能力要强，建议提前去考 CSP，可以抵机试。\n   清华大学深圳国际研究生院 计算机技术   时间：7月15日 — 7月19日 安排：第一天下午报道，第二天机试，第三天英语面试 \u0026amp; 心理测试 + 项目汇报，第四天中文面试。 机试：三小时三道题。U盘拷代码。  输入 $N$ 个 $1 \\sim 1000$ 内的整数，输出排序结果。11 给一个数 $x$，初始化为0，做 2 号变换是 $2x+1$，做 3 号变换是$2x+2$，输入一个数，输出从 $0$ 开始到变成这个数要经过的最少变换，比如输入 $10$ 就输出 $233$。12 输入$n, m$ ，从 $1$ 到 $n$ 的自然数数列，隔 $m$ 个数做一次符号变换，比如输入 $8, 2$ ，就是序列 $-1, -2, 3, 4, -5, -6, 7, 8$，求这个序列的和。13   项目：3个人一组（随机分），做一个小项目。可选题，第一题是用多种非深度方法做一个分类或者回归，第二题是街景数字识别，任务和实现方法都自己定。 英语面试 \u0026amp; 心理测试  心理测试：来清华的目的，如何实现它？ 英语面试：和北航很像，抽一张纸，像是一篇英文论文的摘要，朗读并翻译。 英文介绍你的大学以及你的大学生活。   中文面试  十分钟 PPT 自我介绍。 五分钟老师提问，全扯项目去了。    清华的夏令营有很多个项目，计算机技术只收了25个人，生源特别好，清一色中上流985，甚至有清本的学生。考核项目也很多，每天都有至少两个任务并行，一天就能睡5、6个小时（仅个人情况），也有见到一些同学，即使在这样高强度的压力下，还是可以很从容地把每一件事都做得特别好，不服不行，让我看到了我和优秀营员之间很明显的差距。\n夏令营结束大概四五天，结果出来未录取，也没有太出乎意料。后面到九月份有个老师有和我联系，但是不太喜欢他的方向，后面也就没去成清华。如果想去清华深研院的话，提前联系老师很重要，入营的基本全都提前联系过导师。另外也别光看是清华，陶瓷的时候就不关心导师的为人了（导师评价网）。总的来说，这个夏令营会比较看重科研能力，有论文的话会很有优势，反而基础的计算机知识考察的不多。\n   北京大学深圳研究生院 计算机应用技术   时间：9月21日 — 9月22日 安排：只有面试。 面试：  英文自我介绍。 四个信封（数学、算法、计算机基础、开放类问题）必抽数学，里面题目是：两个人抛硬币吃苹果，抛到正面的吃，先抛会不会有优势。 自己再抽一个信封，我抽了算法，把一个数组里面所有零挪到数组的最后，分析时空复杂度。 问我最擅长的科目，我说数据结构，然后他就问了我计算机网络……分别问了七层架构还有 web、internet、network 区别。 描述强化学习（我的项目）。 拿了几个 offer ，去哪个。    到这个时间节点就已经是九推了，北大深研院比较爱要夏令营的学生，而我当时没有联系老师没有入营，九推感觉就比较吃亏一些。关于面试的过程，一直到我回答完算法题，老师似乎都没有在听，一直都在传一些我的资料，感觉自己擅长的科目基本都被略过去了。后面那几个英文概念问题真是把我问懵了，这里就被怼了几句基础不行，当时就觉得凉了一半。后面问 offer 的事情，我也如实说了，现在看来可能有点隐瞒还会好点？当时成绩出来排在候补第十位左右，最后到9月28号我在系统上填完北航之后，学校那边才跟我说补录的事情，自然也就没有机会了。\n   浙江大学计算机学院 计算机科学与技术    时间：9月23日 — 9月24日\n  安排：第一天机试，第二天面试。\n  机试：浙大用PTA，英文题目，可以提前考拿去抵（甲级或顶级），做题时每道题都可以看到得分以及实时排名，貌似是不罚时，机试难度说是大概在甲级到顶级左右，但是今年题目感觉比甲级简单。\n 一个正数，各个位数加起来的和代替当前的数字，直到这个数等于一，如果出现循环，则输出循环开始的第一个数。 给若干数以及一个宽度，按 $Z$ 字型输出，比如给出 $1, 2, \\dots , 13$ 以及 $5$ 那输出的结果就是：  1 2 3  1 2 3 4 5 10 9 8 7 6 11 12 13   给出一个二叉搜索树的先序遍历，注意这里的二叉搜索树还可以是镜像的（即插入时大的放左子树，小的放右子树），判断是否是平衡二叉树。 给出 $n$ 个人的 $m$ 个关系，关系输入的是两个数字，代表对应编号的两个人是朋友关系，问从其中取出若干个人，只考虑他们之间的关系，输出最多朋友的三个人，相同则按编号由小到大输出。    面试：\n 红白纸 英文介绍项目 构造函数前面能不能加 private ，有什么用 全局变量前面能不能加 static ，有什么用 编译，预编译，汇编，连接 问了点项目 支不支持 FLG    浙大的机试我满分出来之前看了一眼，至少已经有三四十个满分了。所以主要就是看面试，面试我答的特别差，只能说自己的基础知识还是不够扎实。最后录取名单里面不出意料我又是排在候补，也是第十位左右，九月底打电话说有专硕的名额了，但是不想对北航那边的招生造成影响，就拒掉了。\n   写在最后  不得不说保研路上真的有很多时候要看运气。应该说，实力决定下限，运气决定上限。努力了，不后悔，我觉得就够了。其实研究生也并不是终点，同样的道理，研究生的院校也就能决定个下限，自己的努力才能决定将来的上限。所以，尽人事，听天命吧。最后祝愿学弟学妹们都能保上自己理想的院校。\n  人大、北理、北航等高校认可\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 主要是浙大认可\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 神仙打架\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 提前联系了老师，但是没过学院的初审，南大似乎不太爱要我们学校的，而且老师在入营方面并没有太大的权力\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 可能需要提前联系老师\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 可以参考 导师评价网 以及跟过该导师的 毕业生 的意见\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 队列＋栈\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 人大基本每年夏令营都会考察C语言的文件操作\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 签到题\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 王道论坛原题，但是测试数据很水，long long 也能 AC\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 用哈希可以优化到 $O(n)$\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 输入的数转成二进制，看每一位是 $1$ 还是 $0$ 就知道要做几号变换，可以优化到 $O(\\log n)$\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 数学题，可以优化到 $O(1)$，答案是 $\\displaystyle\\frac{mn}{2}$\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"Jun 06","permalink":"https://blog.chenjr.top/post/summer-camp/","tags":["保研"],"title":"2019年计算机专业保研夏令营经历"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.chenjr.top/articles/","tags":null,"title":"所有文章"}]