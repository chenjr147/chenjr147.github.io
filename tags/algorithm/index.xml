<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on kevin</title>
    <link>https://blog.chenjr.top/tags/algorithm/</link>
    <description>Recent content in Algorithm on kevin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 16 Jul 2021 13:52:42 +0800</lastBuildDate><atom:link href="https://blog.chenjr.top/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 第 56 场双周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-biweekly-56/</link>
      <pubDate>Fri, 16 Jul 2021 13:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-biweekly-56/</guid>
      <description>Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/count-square-sum-triples/&amp;#34;&amp;gt;统计平方和三元组的数目&amp;lt;/a&amp;gt;     思路  第一题无脑暴力 $O(n^3)$ 即可。
赛后补一份容易想到的 $O(n^2)$ 的双指针代码。评论区给出了复杂度更低的算法，但需要前置的数学知识，并不太容易在面试中想出来，在这里也就不再赘述了。
   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Algorithm: two pointers # Time Complexity: O(n^2) # Space Complexity: O(1) class Solution: def countTriples(self, n: int) -&amp;gt; int: ans = 0 for c in range(1, n + 1): target = c * c a, b = 1, c - 1 while a &amp;lt;= b: result = a * a + b * b if result == target: ans += 1 if a == b else 2 a += 1 b -= 1 elif result &amp;lt; target: a += 1 else: b -= 1 return ans      Q2.</description>
    </item>
    
    <item>
      <title>LeetCode 第 248 场周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-weekly-248/</link>
      <pubDate>Sun, 04 Jul 2021 13:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-weekly-248/</guid>
      <description>起晚了没赶上:(
   Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/build-array-from-permutation/&amp;#34;&amp;gt;基于排列构建数组&amp;lt;/a&amp;gt;     思路  阅读理解。
   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14  // Algorithm: simulation // Time Complexity: O(n), n = nums.size() // Space Complexity: O(n) class Solution { public: vector&amp;lt;int&amp;gt; buildArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; ans(n); for (int i = 0; i &amp;lt; n; ++i) { ans[i] = nums[nums[i]]; } return ans; } };      Q2.</description>
    </item>
    
    <item>
      <title>LeetCode 第 247 场周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-weekly-247/</link>
      <pubDate>Thu, 01 Jul 2021 13:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-weekly-247/</guid>
      <description>Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/&amp;#34;&amp;gt;两个数对之间的最大乘积差&amp;lt;/a&amp;gt;     思路  注意到数据范围 1 &amp;lt;= nums[i] &amp;lt;= 10^4，可以想到使用排序解决本问题。
   代码  1 2 3 4 5 6 7  # Algorithm: sort + greed # Time Complexity: O(n), n = len(nums) # Space Complexity: O(1) class Solution: def maxProductDifference(self, nums: List[int]) -&amp;gt; int: nums.sort() return nums[-1] * nums[-2] - nums[0] * nums[1]      Q2. &amp;lt;a href=&amp;#34;https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>LeetCode 第 55 场双周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-biweekly-55/</link>
      <pubDate>Sun, 27 Jun 2021 13:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-biweekly-55/</guid>
      <description>Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/&amp;#34;&amp;gt;删除一个元素使数组严格递增&amp;lt;/a&amp;gt;     思路  观察并分析，可以发现仅存在两种合法情况，逐一考虑即可。
   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // Algorithm: two pointer // Time Complexity: O(n), n = nums.size() // Space Complexity: O(1) class Solution { public: bool canBeIncreasing(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int n = nums.</description>
    </item>
    
    <item>
      <title>LeetCode 第 246 场周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-weekly-246/</link>
      <pubDate>Sun, 20 Jun 2021 13:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-weekly-246/</guid>
      <description>Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/largest-odd-number-in-string/&amp;#34;&amp;gt;字符串中的最大奇数&amp;lt;/a&amp;gt;     思路  从后往前找到第一个奇数即可。
   代码  1 2 3 4 5 6 7 8 9  class Solution: def largestOddNumber(self, num: str) -&amp;gt; str: # Algorithm: tranform and conquer # Time Complexity: O(n), n = len(num) # Space Complexity: O(1) for i in range(len(num) - 1, -1, -1): if int(num[i]) % 2 == 1: return num[:i + 1] return &amp;#34;&amp;#34;      Q2.</description>
    </item>
    
    <item>
      <title>LeetCode 第 245 场周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-weekly-245/</link>
      <pubDate>Tue, 15 Jun 2021 11:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-weekly-245/</guid>
      <description>Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal/&amp;#34;&amp;gt;重新分配字符使所有字符串都相等&amp;lt;/a&amp;gt;     思路  字符串间的移动是任意的，那么我们只需要统计所有字符出现的次数，检查其是否为 $\texttt{words.size()}$ 的整数倍即可。
   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution { public: bool makeEqual(vector&amp;lt;string&amp;gt;&amp;amp; words) { // Algorithm: transform and conquer  // Time Complexity: O(n), n = sum(len(words[i]))  // Space Complexity: O(1)  array&amp;lt;int, 26&amp;gt; cnt{}; for (auto&amp;amp;&amp;amp; word : words) { for (auto&amp;amp;&amp;amp; ch : word) { cnt[ch - &amp;#39;a&amp;#39;] += 1; } } int n = static_cast&amp;lt;int&amp;gt;(words.</description>
    </item>
    
    <item>
      <title>LeetCode 第 54 场双周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-biweekly-54/</link>
      <pubDate>Sun, 13 Jun 2021 23:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-biweekly-54/</guid>
      <description>Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/&amp;#34;&amp;gt;检查是否区域内所有整数都被覆盖&amp;lt;/a&amp;gt;     思路  模拟
   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -&amp;gt; bool: # Algorithm: simulation # Time Complexity: O(n * m), n = right - left + 1, m = len(ranges) # Space Complexity: O(1) for cur in range(left, right + 1): ok = False for begin, end in ranges: if begin &amp;lt;= cur &amp;lt;= end: ok = True break if not ok: return False return True      Q2.</description>
    </item>
    
    <item>
      <title>剑指 offer</title>
      <link>https://blog.chenjr.top/post/sword-to-offer/</link>
      <pubDate>Thu, 10 Jun 2021 23:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/sword-to-offer/</guid>
      <description>顺序参考牛客网 - 剑指 offer
   JZ1. 二维数组中的查找     思路  从数组的右上或左下开始查找，可以有效地进行减治。
   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: bool Find(int target, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; array) { // Algorithm: decrease and conquer  // Time Complexity: O(n), n = array.</description>
    </item>
    
    <item>
      <title>LeetCode 第 244 场周赛</title>
      <link>https://blog.chenjr.top/post/leetcode-weekly-244/</link>
      <pubDate>Wed, 09 Jun 2021 23:52:42 +0800</pubDate>
      
      <guid>https://blog.chenjr.top/post/leetcode-weekly-244/</guid>
      <description>Q1. &amp;lt;a href=&amp;#34;https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/&amp;#34;&amp;gt;判断矩阵经轮转后是否一致&amp;lt;/a&amp;gt;     思路  容易发现，旋转四次 mat 即回到了原始状态。
所以我们只需要至多旋转三次 mat ，每次判断是否和 target 一致即可。
   代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution { public: bool findRotation(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; target) { // Algorithm: simulation  // Time Complexity: O(n^2), n = mat.</description>
    </item>
    
  </channel>
</rss>
