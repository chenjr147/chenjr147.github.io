<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Kevin's Blog</title><link>https://blog.chenjr.top/tags/leetcode/</link><description>Recent content in LeetCode on Kevin's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 07 Nov 2021 22:28:57 +0800</lastBuildDate><atom:link href="https://blog.chenjr.top/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 第 266 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-266/</link><pubDate>Sun, 07 Nov 2021 22:28:57 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-266/</guid><description>Q1. 统计字符串中的元音子字符串 来源：力扣（LeetCode）
链接： https://leetcode-cn.com/problems/count-vowel-substrings-of-a-string/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 双指针。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Algorithm: two pointers // Time Complexity: O(n), n = len(word) // Space Complexity: O(n) func countVowelSubstrings(word string) int { ans := 0 for _, s := range strings.FieldsFunc(word, func(r rune) bool { return !strings.ContainsRune(&amp;#34;aeiou&amp;#34;, r) }) { cnt := map[byte]int{} left := 0 for right := range s { cnt[s[right]] += 1 for cnt[s[left]] &amp;gt; 1 { cnt[s[left]] -= 1 left += 1 } if cnt[&amp;#39;a&amp;#39;]*cnt[&amp;#39;e&amp;#39;]*cnt[&amp;#39;i&amp;#39;]*cnt[&amp;#39;o&amp;#39;]*cnt[&amp;#39;u&amp;#39;] &amp;gt; 0 { ans += left + 1 } } } return ans } Q2.</description></item><item><title>LeetCode 第 263 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-263/</link><pubDate>Sun, 17 Oct 2021 21:16:58 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-263/</guid><description>Q1. 检查句子中的数字是否递增 来源：力扣（LeetCode）
链接： https://leetcode-cn.com/problems/check-if-numbers-are-ascending-in-a-sentence/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 模拟。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Algorithm: simulation // Time Complexity: O(n), n = len(s) // Space Complexity: O(n) func areNumbersAscending(s string) bool { last := -1 for _, split := range strings.Split(s, &amp;#34; &amp;#34;) { if unicode.IsDigit(rune(split[0])) { if curr, _ := strconv.Atoi(split); last &amp;lt; curr { last = curr } else { return false } } } return true } Q2.</description></item><item><title>LeetCode 第 63 场双周赛</title><link>https://blog.chenjr.top/post/leetcode-biweekly-63/</link><pubDate>Sun, 17 Oct 2021 14:16:14 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-biweekly-63/</guid><description>Q1. 使每位学生都有座位的最少移动次数 来源：力扣（LeetCode）
链接： https://leetcode-cn.com/problems/minimum-number-of-moves-to-seat-everyone/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 直觉上，我们应该对两个数组进行排序，然后从左到右每个学生依次坐在从左到右的各个位置上。
下面我们采用反证法进行证明，也即需要证明任意调换位置，最终的移动次数只会不变或增多。
假设 $a \leqslant b$, $c \leqslant d$, 则需要证明 $|a-c| + |b-d| \leqslant |a-d| + |b-c|$。
方便起见，同时保证结果不受影响，我们让四个数同减去 $a$，证明如下
\begin{equation} \begin{aligned} |c|+|b-d| &amp;amp;\leqslant |d|+|b-c| \\\\ c^2+2|c||b-d| +(b-d)^2 &amp;amp;\leqslant d^2+2|d||b-c| +(b-c)^2 \\\\ |c||b-d|-bd &amp;amp;\leqslant |d||b-c|-bc \\\\ |c||b-d| - |d||b-c| &amp;amp;\leqslant b(d-c) \\\\ |bc-cd|-|bd-cd| &amp;amp;\leqslant b|d-c| \\\\ |bc-cd|-|bd-cd| &amp;amp;\leqslant|bd-bc| \end{aligned} \end{equation}
此外，我们知道
\begin{equation} \begin{aligned} |x| = |(x-y)+y| &amp;amp;\leqslant |x-y|+|y| \\\\ |x|-|y| &amp;amp;\leqslant |x-y| \end{aligned} \end{equation}</description></item><item><title>LeetCode 第 262 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-262/</link><pubDate>Sun, 10 Oct 2021 17:23:21 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-262/</guid><description>Q1. 至少在两个数组中出现的值 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-out-of-three/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 集合。
代码 1 2 3 4 5 6 7 # Algorithm: set # Time Complexity: O(n), n = sum(len(nums{1..3})) # Space Complexity: O(n) class Solution: def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -&amp;gt; List[int]: s1, s2, s3 = set(nums1), set(nums2), set(nums3) return list((s1 &amp;amp; s2) | (s2 &amp;amp; s3) | (s1 &amp;amp; s3)) Q2. 获取单值网格的最小操作数 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 中位数。原型是 462. 最少移动次数使数组元素相等 II。</description></item><item><title>LeetCode 第 56 场双周赛</title><link>https://blog.chenjr.top/post/leetcode-biweekly-56/</link><pubDate>Fri, 16 Jul 2021 13:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-biweekly-56/</guid><description>Q1. 统计平方和三元组的数目 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/count-square-sum-triples/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 第一题无脑暴力 $O(n^3)$ 即可。
赛后补一份容易想到的 $O(n^2)$ 的双指针代码。评论区给出了复杂度更低的算法，但需要前置的数学知识，并不太容易在面试中想出来，在这里也就不再赘述了。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Algorithm: two pointers # Time Complexity: O(n^2) # Space Complexity: O(1) class Solution: def countTriples(self, n: int) -&amp;gt; int: ans = 0 for c in range(1, n + 1): target = c * c a, b = 1, c - 1 while a &amp;lt;= b: result = a * a + b * b if result == target: ans += 1 if a == b else 2 a += 1 b -= 1 elif result &amp;lt; target: a += 1 else: b -= 1 return ans Q2.</description></item><item><title>LeetCode 第 248 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-248/</link><pubDate>Sun, 04 Jul 2021 13:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-248/</guid><description>起晚了没赶上:(
Q1. 基于排列构建数组 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/build-array-from-permutation/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 阅读理解。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Algorithm: simulation // Time Complexity: O(n), n = nums.size() // Space Complexity: O(n) class Solution { public: vector&amp;lt;int&amp;gt; buildArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int n = nums.size(); vector&amp;lt;int&amp;gt; ans(n); for (int i = 0; i &amp;lt; n; ++i) { ans[i] = nums[nums[i]]; } return ans; } }; Q2. 消灭怪物的最大数量(https://leetcode-cn.</description></item><item><title>LeetCode 第 247 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-247/</link><pubDate>Thu, 01 Jul 2021 13:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-247/</guid><description>Q1. 两个数对之间的最大乘积差 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 注意到数据范围 1 &amp;lt;= nums[i] &amp;lt;= 10^4，可以想到使用排序解决本问题。
代码 1 2 3 4 5 6 7 # Algorithm: sort + greed # Time Complexity: O(n), n = len(nums) # Space Complexity: O(1) class Solution: def maxProductDifference(self, nums: List[int]) -&amp;gt; int: nums.sort() return nums[-1] * nums[-2] - nums[0] * nums[1] Q2. 循环轮转矩阵 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/cyclically-rotating-a-grid/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 模拟即可，注意细节。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Algorithm: simulation # Time Complexity: O(n * m), n = len(grid), m = len(grid[0]) # Space Complexity: O(n + m) class Solution: def rotateGrid(self, grid: List[List[int]], k: int) -&amp;gt; List[List[int]]: n, m = len(grid), len(grid[0]) for i in range(ceil(min(n, m) / 2)): nums = list() x = y = i # x, y = i, i while y &amp;lt; m - i - 1: nums.</description></item><item><title>LeetCode 第 55 场双周赛</title><link>https://blog.chenjr.top/post/leetcode-biweekly-55/</link><pubDate>Sun, 27 Jun 2021 13:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-biweekly-55/</guid><description>Q1. 删除一个元素使数组严格递增 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 观察并分析，可以发现仅存在两种合法情况，逐一考虑即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Algorithm: two pointer // Time Complexity: O(n), n = nums.size() // Space Complexity: O(1) class Solution { public: bool canBeIncreasing(vector&amp;lt;int&amp;gt; &amp;amp;nums) { int n = nums.size(); // if we remove nums[x], whether array is increasing auto check = [&amp;amp;](int x) { int last = 0; for (int i = 0; i &amp;lt; n; ++i) { if (i !</description></item><item><title>LeetCode 第 246 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-246/</link><pubDate>Sun, 20 Jun 2021 13:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-246/</guid><description>Q1. 字符串中的最大奇数 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/largest-odd-number-in-string/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 从后往前找到第一个奇数即可。
代码 1 2 3 4 5 6 7 8 9 class Solution: def largestOddNumber(self, num: str) -&amp;gt; str: # Algorithm: tranform and conquer # Time Complexity: O(n), n = len(num) # Space Complexity: O(1) for i in range(len(num) - 1, -1, -1): if int(num[i]) % 2 == 1: return num[:i + 1] return &amp;#34;&amp;#34; Q2. 你完成的完整对局数 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 模拟即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution: # Algorithm: simulation # Time Complexity: O(1) # Space Complexity: O(1) def isOver(self, startHour: int, startMinute: int, finishHour: int, finishMinute: int) -&amp;gt; int: return (startHour * 60 + startMinute) &amp;gt; (finishHour * 60 + finishMinute) def numberOfRounds(self, startTime: str, finishTime: str) -&amp;gt; int: startHour, startMinute = map(int, startTime.</description></item><item><title>LeetCode 第 245 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-245/</link><pubDate>Tue, 15 Jun 2021 11:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-245/</guid><description>Q1. 重新分配字符使所有字符串都相等 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 字符串间的移动是任意的，那么我们只需要统计所有字符出现的次数，检查其是否为 $\texttt{words.size()}$ 的整数倍即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool makeEqual(vector&amp;lt;string&amp;gt;&amp;amp; words) { // Algorithm: transform and conquer // Time Complexity: O(n), n = sum(len(words[i])) // Space Complexity: O(1) array&amp;lt;int, 26&amp;gt; cnt{}; for (auto&amp;amp;&amp;amp; word : words) { for (auto&amp;amp;&amp;amp; ch : word) { cnt[ch - &amp;#39;a&amp;#39;] += 1; } } int n = static_cast&amp;lt;int&amp;gt;(words.</description></item><item><title>LeetCode 第 54 场双周赛</title><link>https://blog.chenjr.top/post/leetcode-biweekly-54/</link><pubDate>Sun, 13 Jun 2021 23:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-biweekly-54/</guid><description>Q1. 检查是否区域内所有整数都被覆盖 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 模拟
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -&amp;gt; bool: # Algorithm: simulation # Time Complexity: O(n * m), n = right - left + 1, m = len(ranges) # Space Complexity: O(1) for cur in range(left, right + 1): ok = False for begin, end in ranges: if begin &amp;lt;= cur &amp;lt;= end: ok = True break if not ok: return False return True Q2.</description></item><item><title>LeetCode 第 244 场周赛</title><link>https://blog.chenjr.top/post/leetcode-weekly-244/</link><pubDate>Wed, 09 Jun 2021 23:52:42 +0800</pubDate><guid>https://blog.chenjr.top/post/leetcode-weekly-244/</guid><description>Q1. 判断矩阵经轮转后是否一致 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 容易发现，旋转四次 mat 即回到了原始状态。
所以我们只需要至多旋转三次 mat ，每次判断是否和 target 一致即可。
代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: bool findRotation(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; mat, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; target) { // Algorithm: simulation // Time Complexity: O(n^2), n = mat.size() // Space Complexity: O(n^2), n = mat.size() // Corner Case: if (mat == target) return true; // Normal Case: int n = static_cast&amp;lt;int&amp;gt;(mat.</description></item></channel></rss>